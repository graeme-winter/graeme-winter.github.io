# Kernel Modules

One of the great things about the π is the ability to hack at the lowest levels, and break something which doesn't matter. In addition to exploring bare metal on BCM2835, also started to look at writing kernel modules, since that is the usual MO for interfacing to hardware.

Spoiler: the kernel makes this harder, because its job is to stop you from messing with hardware. This is fine, but meant that the writing of a new kernel module was something of a learning curve. As such, work with something with which I am already familiar, GPCLK as per [previous user space investigations](../07/2023-07-04.md).

## Kernel Basics

In UNIX everything is a file, so if you want to expose a device, you create a file to do so. The file in this case lives under `/dev`, and wants to expose a clock divider register - I will assume that the clock has been set up as per the data sheet in advance (I used the user space program from before).

Device file needs to deal with four ideas:

- activity when opened
- activity when released (closed)
- action on read
- action on write

These four functions are essentially what defines the minimal functionality exposed by a character device. The API for these (i.e. stubs) is well documented, but the _behaviour_ expected from these is less well documented. That behaviour _matters_. You also need two other stub functions, to `init` and `exit` the kernel module (i.e. routines which are executed on load and unload).

## Memory

Obviously for something like an ARM based SoC everything is accessed by specific memory addresses - in the most basic sense the job of the kernel is to map the machine hardware to a set of predictable locations in a process memory space, and to prevent one program from clobbering another. In our case, we want to access memory which is shared by other devices / programs / whatever so need to think about accessing the right space. In kernel terms, this involves _mapping_ the memory from the bus address that the CPU sees to the right address for access from a kernel module: this is done with `ioremap` and `iounmap` - former to perform the mapping, latter to release it. The hardware address of the hardware depends on the specific revision of π - in my case, working on π0 for this where we have 512MB of RAM, the base address is one byte above i.e. `#define GPCLK_ADDR 0x20101070`. In the data sheet this is listed with prefix `0x7E`...
