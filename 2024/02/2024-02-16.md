# RP2040 Quadrature

Task zero along the way to making the device be a general purpose encoder capture, readback, pulse generating device. Want to be able to set it up, trigger, send pulses, record readback positions from quadrature decoders when pulse sent etc.

This will involve PIO blocks, interrupt handlers.

From ÂµPython of course, because _flexible_, though the interrupt handlers may need to be written in C.

## Signal generator

Task zero is remembering how to make a quadrature signal - of course this would be fairly trivial to do with PWM blocks, but that is not very flexible. The PIO is much more flexible for this:

```python
import time

from machine import Pin
import rp2

@rp2.asm_pio(out_init=(rp2.PIO.OUT_LOW, rp2.PIO.OUT_LOW))
def square():
    mov(osr, isr)
    out(pins, 2)
    mov(x, y)
    label("a")
    jmp(x_dec, "a")
    nop()
    out(pins, 2)
    mov(x, y)
    label("b")
    jmp(x_dec, "b")
    nop()
    out(pins, 2)
    mov(x, y)
    label("c")
    jmp(x_dec, "c")
    nop()
    out(pins, 2)
    mov(x, y)
    label("d")
    jmp(x_dec, "d")

# output pins - since this is not going through the GPIO multiplexer probably
# don't need to set these up at all...
p0 = machine.Pin(0, machine.Pin.OUT)
p1 = machine.Pin(1, machine.Pin.OUT)

sm0 = rp2.StateMachine(0, square, out_base=p0)
sm0.put(31250 - 4)
sm0.exec("pull()")
sm0.exec("mov(y, osr)")
sm0.put(0b01111000 << 24)
sm0.exec("pull()")
sm0.exec("mov(isr, osr)")

sm0.active(1)
time.sleep(100)
sm0.active(0)
```

!['scope trace](./quad-1kHz.png)

That much works, then. However vastly simpler to use `set`:

```python
from machine import Pin
import rp2

@rp2.asm_pio(set_init=(rp2.PIO.OUT_LOW, rp2.PIO.OUT_LOW))
def quad():
    wrap_target()
    pull()
    mov(x, osr)
    label("start")
    set(pins, 1)[1]
    set(pins, 3)[1]
    set(pins, 2)[1]
    set(pins, 0)
    jmp(x_dec, "start")
    mov(isr, invert(x))
    push()
    wrap()    

p0 = machine.Pin(0, machine.Pin.OUT)
p1 = machine.Pin(1, machine.Pin.OUT)

sm0 = rp2.StateMachine(0, quad, freq=8_000_000, set_base=p0)
sm0.put(1_000_000 - 1)
sm0.active(1)
sm0.get()
sm0.active(0)
```

This will send 1,000,000 cycles (4 counts) at 1MHz i.e. 4 million encoder counts / second => can use to test incrementing by a fixed number, and reverse it as a second program to test reversing the count (1, 3, 2, 0 -> 2, 3, 1, 0). One cycle (increase by 4 count) example:

![Pulse generated by moving from state 0, 1, 3, 2, 0 sequence](./pulse.png)
