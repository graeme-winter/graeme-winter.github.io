# PIO debugging (less trivial)

A less trivial example for the PIO debugging: the interaction between a pair of state machines, which between them are implementing advancing and retarding the A, B signal combinations for a quadrature encoder: this shows tracking the behaviour of a pair of state machines working together.

This is a key part of the test program for the pico-panda implementation project - driving a quadrature input with deterministic behaviour is critical for this.

## PIO programs

The first part of this is the basic quadrature signal generator:

```python
from machine import Pin, mem32
import rp2


# quadrature sequence generators: working in multiples of 4 such that a 
# full sequence returns to the original state: incr and decr functions:
# sm.put(NN//4) to increment by NN counts

@rp2.asm_pio(set_init=(rp2.PIO.OUT_LOW, rp2.PIO.OUT_LOW))
def incr():
    wrap_target()
    pull()
    mov(x, osr)
    label("start")
    set(pins, 1)[1]
    set(pins, 3)[1]
    set(pins, 2)[1]
    set(pins, 0)
    jmp(x_dec, "start")
    mov(isr, invert(x))
    push()
    wrap()


@rp2.asm_pio(set_init=(rp2.PIO.OUT_LOW, rp2.PIO.OUT_LOW))
def decr():
    wrap_target()
    pull()
    mov(x, osr)
    label("start")
    set(pins, 2)[1]
    set(pins, 3)[1]
    set(pins, 1)[1]
    set(pins, 0)
    jmp(x_dec, "start")
    mov(isr, invert(x))
    push()
    wrap()


# generate 4 x OUT pins though only two are used at the moment for the
# quadrature output
pins = [Pin(j, Pin.OUT) for j in range(4)]

# PIO1 blocks for signal generation: using SM 4, 5 i.e. PIO1 SM 0, 1
sm4 = rp2.StateMachine(4, incr, freq=62_500_000, set_base=pins[0])
sm5 = rp2.StateMachine(5, decr, freq=62_500_000, set_base=pins[0])
```

At this point you would usually just enable sm4, or sm5, then `put` values in for the number of counts. In the case of debugging however we don't enable, just step through from assembly code which enables and disables with a two tick delay between one and the next: N.B. clock divider set to two above by using `freq=62_500_000`.

```python
from disasm import disasm


PIO0_BASE = 0x50200000
PIO1_BASE = 0x50300000


# advance one or more PIO SMs on PIO block pointed at by r0 masked by r1
# call with e.g. advance(PIO1_BASE, 0x3) to advance SM 4, 5 by one tick
@micropython.asm_thumb
def advance(r0, r1):
    mov(r2, 0)
    str(r1, [r0, 0])
    str(r2, [r0, 0])
    mov(r0, 0)


# incr and decr by m counts n times
@micropython.native
def updown(n, m):
    for j in range(n):
        sm4.put((m // 4) - 1)
        sm4.active(1)
        sm4.get()
        sm4.active(0)
        sm5.put((m // 4) - 1)
        sm5.active(1)
        sm5.get()
        sm5.active(0)


# simply increment by m counts
@micropython.native
def up(m):
    sm4.put((m // 4) - 1)
    sm4.active(1)
    sm4.get()
    sm4.active(0)


# simply decrement by m counts
@micropython.native
def down(m):
    sm5.put((m // 4) - 1)
    sm5.active(1)
    sm5.get()
    sm5.active(0)


# example case: incremenet by 8 counts (i.e. two full cycles) on SM4
# then decrement by the same number on SM5, printing the instructions
# being executed on every step

NN = 8
k = 0

sm4.put((NN // 4) - 1)
for j in range(2 * NN + 4):
    k += 1
    print(
        "%04x %20s %20s"
        % (
            k,
            " ".join(disasm(mem32[PIO1_BASE | 0xD8], 0, False)),
            " ".join(disasm(mem32[PIO1_BASE | 0xF0], 0, False)),
        )
    )
    advance(PIO1_BASE, 0x3)
sm4.get()

sm5.put((NN // 4) - 1)
for j in range(2 * NN + 4):
    k += 1
    print(
        "%04x %20s %20s"
        % (
            k,
            " ".join(disasm(mem32[PIO1_BASE | 0xD8], 0, False)),
            " ".join(disasm(mem32[PIO1_BASE | 0xF0], 0, False)),
        )
    )
    advance(PIO1_BASE, 0x3)
sm5.get()

# to show we are ended print the current SM instructions: both are
# stuck on pull block so we are waiting for > 1 sm.put() instructions
# from the calling routine

k += 1
print(
    "%04x %20s %20s"
    % (
        k,
        " ".join(disasm(mem32[PIO1_BASE | 0xD8], 0, False)),
        " ".join(disasm(mem32[PIO1_BASE | 0xF0], 0, False)),
    )
)
advance(PIO1_BASE, 0x3)
```

This will show precisely the timing that the PIO units are taking to perform the tasks:

```
0001          pull block           pull block 
0002           mov x osr           pull block 
0003       set pins 1 [1]          pull block 
0004       set pins 3 [1]          pull block 
0005       set pins 3 [1]          pull block 
0006       set pins 2 [1]          pull block 
0007       set pins 2 [1]          pull block 
0008          set pins 0           pull block 
0009          set pins 0           pull block 
000a        jmp x-- 0x19           pull block 
000b       set pins 1 [1]          pull block 
000c       set pins 3 [1]          pull block 
000d       set pins 3 [1]          pull block 
000e       set pins 2 [1]          pull block 
000f       set pins 2 [1]          pull block 
0010          set pins 0           pull block 
0011          set pins 0           pull block 
0012        jmp x-- 0x19           pull block 
0013          mov isr !x           pull block 
0014          push block           pull block 
0015          pull block           pull block 
0016          pull block            mov x osr 
0017          pull block        set pins 2 [1]
0018          pull block        set pins 3 [1]
0019          pull block        set pins 3 [1]
001a          pull block        set pins 1 [1]
001b          pull block        set pins 1 [1]
001c          pull block           set pins 0 
001d          pull block           set pins 0 
001e          pull block         jmp x-- 0x10 
001f          pull block        set pins 2 [1]
0020          pull block        set pins 3 [1]
0021          pull block        set pins 3 [1]
0022          pull block        set pins 1 [1]
0023          pull block        set pins 1 [1]
0024          pull block           set pins 0 
0025          pull block           set pins 0 
0026          pull block         jmp x-- 0x10 
0027          pull block           mov isr !x 
0028          pull block           push block 
0029          pull block           pull block 
```

If this was run at the usual clock speed this would take 464ns to run with a clock divider of 2, which would be impossible to watch.
